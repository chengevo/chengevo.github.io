<!DOCTYPE html>
<html lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Lifetime in Rust - Even - A super concise theme for Hugo</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="Every value(or data) in Rust have a lifetime, it starts from the value was created, ends at the owner of the value is dropped. The lifetime discussed most is the liftime of a reference. According to Rust RFC 2094: Non-lexical Lifetimes:
The lifetime of a reference, corresponding to the span of time in which that reference is used. The lifetime of a value, corresponding to the span of time before that value gets freed (or, put another way, before the destructor for the value runs). The distinguish the two, the lifetime of value will be refered as scope of the value. The liftime of a reference cannot outlive the scope of the value it referes to. Let&rsquo;s see an exmaple:
" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.136.5 with theme even" />


<link rel="canonical" href="http://localhost:1313/post/life-time-in-rust/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.287f7169871d27a261faa9e1061c9f0bad401a6a88c196e0802b36967d170094.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="http://localhost:1313/post/life-time-in-rust/">
  <meta property="og:site_name" content="Even - A super concise theme for Hugo">
  <meta property="og:title" content="Lifetime in Rust">
  <meta property="og:description" content="Every value(or data) in Rust have a lifetime, it starts from the value was created, ends at the owner of the value is dropped. The lifetime discussed most is the liftime of a reference. According to Rust RFC 2094: Non-lexical Lifetimes:
The lifetime of a reference, corresponding to the span of time in which that reference is used. The lifetime of a value, corresponding to the span of time before that value gets freed (or, put another way, before the destructor for the value runs). The distinguish the two, the lifetime of value will be refered as scope of the value. The liftime of a reference cannot outlive the scope of the value it referes to. Let’s see an exmaple:">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-11-29T15:27:00+08:00">
    <meta property="article:modified_time" content="2024-11-29T15:27:00+08:00">

  <meta itemprop="name" content="Lifetime in Rust">
  <meta itemprop="description" content="Every value(or data) in Rust have a lifetime, it starts from the value was created, ends at the owner of the value is dropped. The lifetime discussed most is the liftime of a reference. According to Rust RFC 2094: Non-lexical Lifetimes:
The lifetime of a reference, corresponding to the span of time in which that reference is used. The lifetime of a value, corresponding to the span of time before that value gets freed (or, put another way, before the destructor for the value runs). The distinguish the two, the lifetime of value will be refered as scope of the value. The liftime of a reference cannot outlive the scope of the value it referes to. Let’s see an exmaple:">
  <meta itemprop="datePublished" content="2024-11-29T15:27:00+08:00">
  <meta itemprop="dateModified" content="2024-11-29T15:27:00+08:00">
  <meta itemprop="wordCount" content="2059">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Lifetime in Rust">
  <meta name="twitter:description" content="Every value(or data) in Rust have a lifetime, it starts from the value was created, ends at the owner of the value is dropped. The lifetime discussed most is the liftime of a reference. According to Rust RFC 2094: Non-lexical Lifetimes:
The lifetime of a reference, corresponding to the span of time in which that reference is used. The lifetime of a value, corresponding to the span of time before that value gets freed (or, put another way, before the destructor for the value runs). The distinguish the two, the lifetime of value will be refered as scope of the value. The liftime of a reference cannot outlive the scope of the value it referes to. Let’s see an exmaple:">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Even</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Even</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Lifetime in Rust</h1>

      <div class="post-meta">
        <span class="post-time"> 2024-11-29 </span>
        
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#the-lifetiem-of-a-variable"><span class="section-num">1</span> The lifetiem of a variable</a></li>
        <li><a href="#variable-value-and-reference"><span class="section-num">2</span> Variable, value and reference</a></li>
        <li><a href="#assignment-operator-invalidates-a-reference"><span class="section-num">3</span> Assignment operator invalidates a reference</a></li>
        <li><a href="#view-lifetime-as-data-flow"><span class="section-num">4</span> View lifetime as data flow</a></li>
        <li><a href="#the-scope-of-a-lifetime"><span class="section-num">5</span> The scope of a lifetime</a>
          <ul>
            <li><a href="#examples-violating-borrowing-rules">Examples violating borrowing rules</a></li>
            <li><a href="#examples-adhere-to-borrowing-rules">Examples adhere to borrowing rules</a></li>
          </ul>
        </li>
        <li><a href="#multiple-generic-lifetimes"><span class="section-num">6</span> Multiple generic lifetimes</a></li>
        <li><a href="#a-reference-to-a-reference"><span class="section-num">7</span> A reference to a reference</a>
          <ul>
            <li><a href="#and-mut-and-str">&amp;mut &amp;str</a></li>
            <li><a href="#add-lifetiem-annotation">Add lifetiem annotation</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Every value(or data) in Rust have a lifetime, it starts from the value was created, ends at the owner of the value is dropped. The lifetime discussed most is the liftime of a reference. According to <a href="https://rust-lang.github.io/rfcs/2094-nll.html">Rust RFC 2094: Non-lexical Lifetimes</a>:</p>
<blockquote>
<ol>
<li>The lifetime of a reference, corresponding to the span of time in which that reference is used.</li>
<li>The lifetime of a value, corresponding to the span of time before that value gets freed (or, put another way, before the destructor for the value runs).</li>
</ol>
</blockquote>
<p>The distinguish the two, the lifetime of value will be refered as <strong>scope of the value</strong>. The liftime of a reference cannot outlive the scope of the value it referes to. Let&rsquo;s see an exmaple:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="org-coderef--9c6c47-1"><a class="lnlinks" href="#org-coderef--9c6c47-1">1</a>
</span><span class="lnt" id="org-coderef--9c6c47-2"><a class="lnlinks" href="#org-coderef--9c6c47-2">2</a>
</span><span class="lnt" id="org-coderef--9c6c47-3"><a class="lnlinks" href="#org-coderef--9c6c47-3">3</a>
</span><span class="lnt" id="org-coderef--9c6c47-4"><a class="lnlinks" href="#org-coderef--9c6c47-4">4</a>
</span><span class="lnt" id="org-coderef--9c6c47-5"><a class="lnlinks" href="#org-coderef--9c6c47-5">5</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>line <a href="#org-coderef--9c6c47-2">2</a> creates a value, which is a vector, the scope of this values lasts from line <a href="#org-coderef--9c6c47-2">2</a> to line <a href="#org-coderef--9c6c47-4">4</a></li>
<li>line <a href="#org-coderef--9c6c47-3">3</a> creates an reference to the value <code>v</code> (<code>len()</code> method takes an immutable reference), the lifetime of this reference is confined to this line</li>
</ul>
<h2 id="the-lifetiem-of-a-variable"><span class="section-num">1</span> The lifetiem of a variable</h2>
<p>If a variable is binded with a reference, that variable also has a lifetime, which is the scope of code that it can safely be dereferenced<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>. Let&rsquo;s see an example:</p>
<p><a id="code-snippet--lifetime-variable"></a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="org-coderef--362c91-1"><a class="lnlinks" href="#org-coderef--362c91-1">1</a>
</span><span class="lnt" id="org-coderef--362c91-2"><a class="lnlinks" href="#org-coderef--362c91-2">2</a>
</span><span class="lnt" id="org-coderef--362c91-3"><a class="lnlinks" href="#org-coderef--362c91-3">3</a>
</span><span class="lnt" id="org-coderef--362c91-4"><a class="lnlinks" href="#org-coderef--362c91-4">4</a>
</span><span class="lnt" id="org-coderef--362c91-5"><a class="lnlinks" href="#org-coderef--362c91-5">5</a>
</span><span class="lnt" id="org-coderef--362c91-6"><a class="lnlinks" href="#org-coderef--362c91-6">6</a>
</span><span class="lnt" id="org-coderef--362c91-7"><a class="lnlinks" href="#org-coderef--362c91-7">7</a>
</span><span class="lnt" id="org-coderef--362c91-8"><a class="lnlinks" href="#org-coderef--362c91-8">8</a>
</span><span class="lnt" id="org-coderef--362c91-9"><a class="lnlinks" href="#org-coderef--362c91-9">9</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w">          </span><span class="c1">// &#39;a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">;</span><span class="w">             </span><span class="c1">// &#39;b
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="p">;</span><span class="w">             </span><span class="c1">// &#39;c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{a:?}</span><span class="s">&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li><code>&amp;b</code> creates an reference, which has an lifetime <code>'b</code></li>
<li><code>&amp;c</code> creates an reference, which has an lifetime <code>'c</code></li>
<li>variable <code>a</code> is binded to a reference to a <code>Vec&lt;i32&gt;</code>, it&rsquo;s lifetime <code>'a</code> spans from line <a href="#org-coderef--9c6c47-3">3</a> to line <a href="#org-coderef--362c91-8">8</a>, which is the union of <code>'b</code> and <code>'c</code>.</li>
</ol>
<h2 id="variable-value-and-reference"><span class="section-num">2</span> Variable, value and reference</h2>
<p>The book &ldquo;The Rust Programming Language&rdquo; gives an example to introduce the concept lifetime:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="org-coderef--d0315f-1"><a class="lnlinks" href="#org-coderef--d0315f-1"> 1</a>
</span><span class="lnt" id="org-coderef--d0315f-2"><a class="lnlinks" href="#org-coderef--d0315f-2"> 2</a>
</span><span class="lnt" id="org-coderef--d0315f-3"><a class="lnlinks" href="#org-coderef--d0315f-3"> 3</a>
</span><span class="lnt" id="org-coderef--d0315f-4"><a class="lnlinks" href="#org-coderef--d0315f-4"> 4</a>
</span><span class="lnt" id="org-coderef--d0315f-5"><a class="lnlinks" href="#org-coderef--d0315f-5"> 5</a>
</span><span class="lnt" id="org-coderef--d0315f-6"><a class="lnlinks" href="#org-coderef--d0315f-6"> 6</a>
</span><span class="lnt" id="org-coderef--d0315f-7"><a class="lnlinks" href="#org-coderef--d0315f-7"> 7</a>
</span><span class="lnt" id="org-coderef--d0315f-8"><a class="lnlinks" href="#org-coderef--d0315f-8"> 8</a>
</span><span class="lnt" id="org-coderef--d0315f-9"><a class="lnlinks" href="#org-coderef--d0315f-9"> 9</a>
</span><span class="lnt" id="org-coderef--d0315f-10"><a class="lnlinks" href="#org-coderef--d0315f-10">10</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w">                </span><span class="c1">// ---------+-- &#39;a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">                          </span><span class="c1">//          |
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="p">{</span><span class="w">                     </span><span class="c1">//          |
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">        </span><span class="c1">// -+-- &#39;b  |
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w">           </span><span class="c1">//  |       |
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">                     </span><span class="c1">// -+       |
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">                          </span><span class="c1">//          |
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;r: </span><span class="si">{r}</span><span class="s">&#34;</span><span class="p">);</span><span class="w">   </span><span class="c1">//          |
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">                         </span><span class="c1">// ---------+
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>This is how the book explain this code block:</p>
<blockquote>
<p>Here, we’ve annotated the lifetime of r with &lsquo;a and the lifetime of x with &lsquo;b. As you can see, the inner &lsquo;b block is much smaller than the outer &lsquo;a lifetime block. At compile time, Rust compares the size of the two lifetimes and sees that r has a lifetime of &lsquo;a but that it refers to memory with a lifetime of &lsquo;b. The program is rejected because &lsquo;b is shorter than &lsquo;a: the subject of the reference doesn’t live as long as the reference.</p>
</blockquote>
<p>This explaination kind of mixed the three concept together:</p>
<ul>
<li>lifetime of a refernce: <code>&amp;x</code></li>
<li>lifetime of a variable: <code>'a</code></li>
<li>the scope of a value: <code>'b</code></li>
</ul>
<p>I think a better explaination of this example is:</p>
<ul>
<li>variable <code>r</code> binds to a reference to a <code>i32</code>, its lifetime spans from line 2 (when it&rsquo;s initialized) to line <a href="#org-coderef--9c6c47-3">3</a></li>
<li>at line [[out_scope_value] [(a)], a reference to <code>x</code> is created and assigned to variable <code>r</code>. The lifetime of this reference <code>'b</code> confined to this line because at line <a href="#org-coderef--9c6c47-4">4</a> the inner scope ended, which invalidates this reference.</li>
<li>the compiler rejected the code at line <a href="#org-coderef--9c6c47-3">3</a> because it tries to access an invalid reference</li>
</ul>
<h2 id="assignment-operator-invalidates-a-reference"><span class="section-num">3</span> Assignment operator invalidates a reference</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{v:?}</span><span class="s">&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>variable <code>a</code> contains a reference to a <code>Box&lt;i32&gt;</code></li>
<li>at line 4 the variable <code>v</code> is assigned to a new value, the assignment runs the destructor of value this variable previously points to<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>. Because <code>a</code> still contains a reference to the old <code>Box&lt;i32&gt;</code>, this reference is invalidated</li>
</ul>
<h2 id="view-lifetime-as-data-flow"><span class="section-num">4</span> View lifetime as data flow</h2>
<p>In the book <em>Rust for Rustaceans<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup></em>, Jon Gjengset proposed a different approach to think about lifetime:</p>
<blockquote>
<p>It(borrow checker) does this by tracing the path back to where &lsquo;a starts—where the reference was taken—from the point of use and checking that there are no conflicting uses along that path.</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="org-coderef--734273-1"><a class="lnlinks" href="#org-coderef--734273-1"> 1</a>
</span><span class="lnt" id="org-coderef--734273-2"><a class="lnlinks" href="#org-coderef--734273-2"> 2</a>
</span><span class="lnt" id="org-coderef--734273-3"><a class="lnlinks" href="#org-coderef--734273-3"> 3</a>
</span><span class="lnt" id="org-coderef--734273-4"><a class="lnlinks" href="#org-coderef--734273-4"> 4</a>
</span><span class="lnt" id="org-coderef--734273-5"><a class="lnlinks" href="#org-coderef--734273-5"> 5</a>
</span><span class="lnt" id="org-coderef--734273-6"><a class="lnlinks" href="#org-coderef--734273-6"> 6</a>
</span><span class="lnt" id="org-coderef--734273-7"><a class="lnlinks" href="#org-coderef--734273-7"> 7</a>
</span><span class="lnt" id="org-coderef--734273-8"><a class="lnlinks" href="#org-coderef--734273-8"> 8</a>
</span><span class="lnt" id="org-coderef--734273-9"><a class="lnlinks" href="#org-coderef--734273-9"> 9</a>
</span><span class="lnt" id="org-coderef--734273-10"><a class="lnlinks" href="#org-coderef--734273-10">10</a>
</span><span class="lnt" id="org-coderef--734273-11"><a class="lnlinks" href="#org-coderef--734273-11">11</a>
</span><span class="lnt" id="org-coderef--734273-12"><a class="lnlinks" href="#org-coderef--734273-12">12</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="p">;</span><span class="w">             </span><span class="c1">// &#39;a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{a}</span><span class="s">&#34;</span><span class="p">);</span><span class="w">        </span><span class="c1">// &#39;a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="p">;</span><span class="w">                 </span><span class="c1">// &#39;a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{a}</span><span class="s">&#34;</span><span class="p">);</span><span class="w">            </span><span class="c1">// &#39;a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>the liftime <code>'a</code> starts at line <a href="#org-coderef--734273-3">3</a> when a reference to <code>v</code> is created. It spans from line <a href="#org-coderef--734273-3">3</a> to line <a href="#org-coderef--734273-6">6</a>.</li>
<li><code>'a</code> ends at line <a href="#org-coderef--734273-7">7</a> because the <a href="#assignment-operator-invalidates-a-reference">assignment operator</a> destroyed the Box <code>a</code> referes to</li>
<li><code>'a</code> starts again when variable <code>a</code> is updated at line <a href="#org-coderef--734273-8">8</a>
<ul>
<li>if the code loops back to line <a href="#org-coderef--734273-6">6</a>, <code>a</code> still has a valid reference. The lifetime <code>'a</code> will ended at line <a href="#org-coderef--734273-6">6</a> again, and begins next create then destroyed cycle.</li>
<li>if the code continues to the final print statement, <code>a</code> has a valid reference too, the lifetime <code>'a</code> now spans from line <a href="#org-coderef--734273-8">8</a> to <a href="#org-coderef--734273-11">11</a>.</li>
</ul>
</li>
</ul>
<h2 id="the-scope-of-a-lifetime"><span class="section-num">5</span> The scope of a lifetime</h2>
<p>The lifetime of a reference last only for those portions of the function in which the reference may later be used<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>, instead of as large as the entire scope of the variable, which usually stretch to the end of the code block. With that in mind, let&rsquo;s look at the following code.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w">                 </span><span class="c1">// &#39;a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">a</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w">                      </span><span class="c1">// &#39;a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;len: </span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">len</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>At line 3, we takes a mutable reference to <code>v</code>, the lifetime of this lifetime <code>'a</code> lasts from line 3 to line 4. Because this reference is last used in line 4, so the compiler considers the lifetime ends here, instead of line 6.</p>
<p>Having understanding the scope of a reference, we can now make the borrowing rules more sprcific:</p>
<ol>
<li><strong>At runtime</strong>, you can have either one mutable reference or any number of immutable references to access a value</li>
<li>there can be multiple mutable reference existing in the same block, as long as their lifetime doens&rsquo;t overlaps</li>
<li>a mutable reference and immutable references can exists in the same block only if the lifetime of immutable references does not overlap with the lifetime of the mutable reference</li>
</ol>
<p>Let&rsquo;s play around with more examples.</p>
<h3 id="examples-violating-borrowing-rules">Examples violating borrowing rules</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">r2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">r3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// scope of mutable reference overlaps with immutable references
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{r1}</span><span class="s">, </span><span class="si">{r2}</span><span class="s">, </span><span class="si">{r3}</span><span class="s">&#34;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// incorrect, mutable borrow used here, starts and ends here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{:?}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">first</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="examples-adhere-to-borrowing-rules">Examples adhere to borrowing rules</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">r2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{r1}</span><span class="s">, </span><span class="si">{r2}</span><span class="s">&#34;</span><span class="p">);</span><span class="w"> </span><span class="c1">// lifetime of r1 and r2 ends here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">r3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w">  </span><span class="c1">// lifetime of r3 starts here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{r3}</span><span class="s">&#34;</span><span class="p">);</span><span class="w"> </span><span class="c1">// lifetime of  r3 ends here, not overlaping with immutables references
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="multiple-generic-lifetimes"><span class="section-num">6</span> Multiple generic lifetimes</h2>
<p>There are times when multiple generic lifetime is necessary, either in a function or in a struct. Consider this function, which takes a string slice <code>s</code> and a delimiter <code>d</code>. Thsi functions aims to find the first occurance of <code>d</code>, and return the part of <code>s</code> that appears before the delimiter. There&rsquo;re two things worthy noting:</p>
<ol>
<li>the delimiter is also a string slice because it may contain multiple characters</li>
<li>right now this function only takes one generic lifetime <code>'a</code>, however this will raise problems which we will talk about later.</li>
</ol>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">before_delimiter</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span> <span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">d</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span> <span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="na">&#39;a</span> <span class="kt">str</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">d</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">pos</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Assume you write another function <code>before_char</code>, which works alike <code>before_delimiter</code>. The only difference is the it returns the part of string slice before an character.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">before_char</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">c</span>: <span class="kt">char</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">before_delimiter</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">d</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;hello world&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;o&#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">before</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">before_char</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">before</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;hell&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Sadly the compiler would reject the function <code>before_char</code>:</p>
<blockquote>
<p>cannot return value referencing local variable <code>d</code></p>
</blockquote>
<p>The reason of this error is, in function <code>before_delimiter</code>, the return value and two parameters have the same lifetime, when this function is called, the generic lifetime is substitited with a concrete liftime, which is the smaller lifetime of <code>s</code> and <code>d</code>. In this example, <code>before_delimiter</code> is called inside <code>before_char</code>, the smaller lifetime is the lifetime of the string reference converted from <code>c</code>: <code>&amp;c.to_string()</code>. However, this lifetime is associated with a variable local to function <code>before_char()</code>.</p>
<p>The solution to this problem is make the parameter in <code>before_delimiter</code> have two distinct lifetimes, and the return value should assign the same lifetime as <code>s</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">before_delimiter</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="na">&#39;b</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span> <span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">d</span>: <span class="kp">&amp;</span><span class="na">&#39;b</span> <span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="na">&#39;a</span> <span class="kt">str</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">d</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">pos</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>This example teaches us that when assigning generic lifetime to parameters and return values, we should thing about which value the returned reference refers to. In <code>before_delimiter</code>, the returned reference and the paramerter <code>s</code> should points to the same value in the memory, so that they should have the same lifetime. With that in mind, that&rsquo;s look at another example.</p>
<h2 id="a-reference-to-a-reference"><span class="section-num">7</span> A reference to a reference</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="c1">// ERROR, require lifetime annotation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span> <span class="nf">strtok</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">delimiter</span>: <span class="kt">char</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">str</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">delimiter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">pre</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">pos</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">*</span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[(</span><span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">..</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">pre</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">pre</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">*</span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">pre</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;hello world hello Rust&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">remainder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">str</span><span class="p">.</span><span class="n">as_str</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">words</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="n">remainder</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s">&#34;&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">before</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strtok</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">remainder</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">words</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">before</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">words</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="s">&#34;hello&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;world&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;hello&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Rust&#34;</span><span class="p">]);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>What <code>strtok</code> does is try to find the delimiter in a string slice, if found returns the part of the string slice before the first occurence of the delimiter, and make the parameter points to what&rsquo;s left in the string slice. For example, if passe in <code>&quot;hello world&quot;</code> and <code>'o'</code> , this function should return &ldquo;hell&rdquo;, and its parameter should points to <code>&quot; world&quot;</code> . The code won&rsquo;t be able to run for now because we need to add lifetime annotation to <code>strtok</code>. But before that, lets think about what&rsquo;s <code>&amp;mut &amp;str</code>.</p>
<h3 id="and-mut-and-str">&amp;mut &amp;str</h3>
<p>The type <code>&amp;mut &amp;str</code> is a mutable reference to a shared string slice. Let&rsquo;s look at following example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;hello world&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">as_str</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">foo</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;hello Rust&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">*</span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="s">&#34;hello Rust&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>variables such as <code>a</code> and <code>b</code> are just named location in the stack.</li>
<li><code>a</code> stores a reference to a shard string slice, you cane make <code>a</code> holding other reference because <code>a</code> is mutable.</li>
<li><code>b</code> also stores a reference, in this case it&rsquo;s a reference to <code>a</code>. However, because <code>b</code> isn&rsquo;t mutable, you cannot make <code>b</code> holding other reference.</li>
</ol>
<h3 id="add-lifetiem-annotation">Add lifetiem annotation</h3>
<p>There two lifetime in the parameter <code>s</code>: <code>&amp;'a mut &amp;'b str</code>. Lifetime <code>'b</code> denotes to how long the reference to the string slice lasts, lifetime <code>'a</code> how long the reference <code>s</code> will exists. Since the return value and the referene to the string slice(<code>'b</code> associated with) points to the same value in the heap, so that the return value should have the the lifetime <code>'b</code>. Because lifetime <code>'a</code> is not needed in the function, we can levae this lifetime annotation empty. Now the function signature of <code>strtok</code> shold look like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">strtok</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">delimiter</span>: <span class="kt">char</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="na">&#39;a</span> <span class="kt">str</span> <span class="p">{</span><span class="w"> </span><span class="c1">//.. }
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p><a href="https://rust-lang.github.io/rfcs/2094-nll.html#what-is-a-lifetime-and-how-does-it-interact-with-the-borrow-checker">As you can see, the lifetime &lsquo;p is part of the type of the variable p. It indicates the portions of the control-flow graph where p can safely be dereferenced</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p><a href="https://doc.rust-lang.org/reference/destructors.html">https://doc.rust-lang.org/reference/destructors.html</a>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p><a href="https://rust-for-rustaceans.com/">https://rust-for-rustaceans.com/</a>&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p><a href="https://rust-lang.github.io/rfcs/2094-nll.html#the-rough-outline-of-our-solution">https://rust-lang.github.io/rfcs/2094-nll.html#the-rough-outline-of-our-solution</a>&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2024-11-29
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        
        
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" class="iconfont icon-github" title="github"></a>
  
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
